import cmath   #добавляем модуль cmath для работы с комплексными числами

def solve_quad(b, c):

    if b**2 - 4*c != b**2:


        #это условие нужно из-за того, что в случае больших b и маленьких c возможна ситуация превышения машинной
        #точности, то есть компьютер не видит разницы между b**2 и b**2 - 4*c.
        #В связи с этим решать уравнение обычным способом можно только при условии, что компьютер видит разницу
        #(машинная точность не превышена) Для этого и напишем такое условие.


        discr = b ** 2 - 4 * c  #стандартная формула для дискриминанта


        if discr > 0:
            x1 = (-b + cmath.sqrt(discr)) / (2)  #формулы уже без коэффициента "а", так как он по условию равен 1
            x2 = (-b - cmath.sqrt(discr)) / (2)
            return (x1, x2)


        elif discr == 0:  #случай кратных корней и вычисление по сокращенной формуле корня
            x = -b / 2
            return (x, x)


        else:
            d = complex(discr)
            x1 = (-b + cmath.sqrt(d)) / 2
            x2 = (-b - cmath.sqrt(d)) / 2

            #случай комплексных корней, используем cmath для нахождения корня(math тут нельзя использовать,
            #так как корень ищется из отрицательного дискриминанта)

            return (x1, x2)
    else:

        #как раз случай, когда машинная точность превышена. В таком случае надо разложить корень в ряд Тейлора около 0
        #и уже тогда считать значения корней приближенно.
        # x1,x2 = (-b +- b*sqrt(1-4*c/(b**2)))/2
        # -> x1,x2 = (-b +- b)/2 -+ c/b
        # Приведем уже итоговые формулы для поиска x1 и x2 и посчитаем по ним

        x1 = -c / b
        x2 = c / b - b

        return (x1, x2)


#выполняем проверку тестами

from numpy import allclose

variants = [{'b': 4.0, 'c': 3.0},
            {'b': 2.0, 'c': 1.0},
            {'b': 0.5, 'c': 4.0},
            {'b': 1e10, 'c': 3.0},
            {'b': -1e10, 'c': 4.0},]

for var in variants:
    x1, x2 = solve_quad(**var)
    print(allclose(x1*x2, var['c']))